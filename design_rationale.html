<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SeekYourSwarm - Design Rationale</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>
    <div class="navbar">
        <div class="navbar_container">
            <a class="navbar_link title" href="index.html">CS5744 - Project 1</a>
            <a class="navbar_link" href="background.html">Background</a>
            <a class="navbar_link" href="use_cases.html">Use Cases</a>
            <a class="navbar_link" href="requirements.html">Requirements</a>
            <a class="navbar_link" href="high_level_design.html">High-Level Design</a>
            <a class="navbar_link" href="modules.html">Modules</a>
            <a class="navbar_link active" href="design_rationale.html">Design Rationale</a>
            <a class="navbar_link" href="conclusion.html">Conclusion</a>
            <a class="navbar_link" href="index.html">Full Text</a>
        </div>
    </div>

    <div id="content">
        <br>
        <h1>Design Rationale</h1>
        <hr>
        <p>Our design rationale is based on a social media format, where club/user data is created and stored on one website. The website (which is the host of our software system) takes the club and user objects and matches them with each other via geolocation algorithms or simple name searches. There is a built-in communication system that facilitates interaction between the club/users and club to club. Finally, the site is linked to a database that stores all relevant information. All these basic functions comprise the necessities of a social media site.</p>
        
        <h3>Function 1: Creating a Club</h3>
        <p>The first step in managing extracurricular clubs within the system is to facilitate the creation and administration of clubs (FR-7, FR-10) and user accounts (FR-4, FR-8). For clubs, this involves setting key details such as the club's name, description, meeting schedule, location, and any specific membership requirements or preferences. In a “manual” management scenario, where administrators and users have full control, the creation of clubs and users is straightforward. Here, the club administrator manually inputs each field, and the software simply stores these values, providing basic validation to ensure correct data formats. For user accounts, the manual process allows users or administrators to define their own information, such as usernames, contact information, and profile preferences, which can then be used to personalize the user's experience within the platform.</p>
        <p>In a more “automated” or “suggestive” use case, additional complexity is introduced that could influence the system’s architecture. In this scenario, the program leverages various algorithms and automated workflows to suggest optimal club attributes or user profiles based on available data. For instance, the system could analyze other club profiles and user interactions to recommend popular meeting times or relevant tags based on user preferences and club characteristics. (NFR-7) User accounts in this mode would also require more extensive system-driven validation and potential onboarding suggestions, such as recommending clubs that align with users' interests. The system may also need to integrate with external data sources, such as academic schedules or geographic information, to optimize club schedules or recommend nearby clubs based on user location data. The system's architecture must also be capable of handling simultaneous requests to create or update clubs and accounts in real time, allowing users and administrators a seamless experience. (NFR-8)</p>
        <p>The need for concurrent and efficient data handling places certain architectural constraints on the system. Among potential styles, the Process Control solution style and the Shared Memory design emerge as suitable options. In the “automated” mode, the Process Control style enables continuous data processing to adjust recommendations based on changing user preferences or newly created clubs, supporting a dynamic and adaptive environment. The Shared Memory design could provide efficient access to static club information, though it may introduce unnecessary complexity if the data is frequently changing and does not need to be retained for all users simultaneously. An Event-Driven design, on the other hand, would be less suitable due to its lack of guaranteed timing, which is critical for synchronized user updates. Given these considerations, a Shared Memory design is best suited to this management function, enabling responsive and adaptive data flows to optimize both club creation and user experience. (NFR-8)</p>

        <h3>Function 2: The Search Function and Geolocation</h3>
        <p>The second step in our system is the search and club-matching algorithm, which is definitely the most critical function of the entire software system. It serves as the primary selling point for our design and is the feature that sets it above other systems like GobblerConnect or Facebook. When a user enters a search, the system takes the user's location and sends the query to the ClubBuffer (described in model 2), which then collects all relevant clubs from the database (described in detail in function 4) that have similar locations to the user (FR-5, NFR-9). The resulting list is then sorted by relevance to the search keywords, after which the ClubBuffer returns the list to then be displayed for the user by the GUI (FR-3, NFR-7). The idea being that the user of our system has a more relevant and realistic idea of the social/communal activities in their local area. </p>
        <p>The only use case for this function is the search function itself and its efficient handling of potentially thousands of queries at once. Its ability to do this is dependent on good system design that emphasizes performance and accuracy, and specifically the ClubBuffer must be able to efficiently retrieve, organize, and collect club data to facilitate adequate data management within our system (NFR-8). As mentioned in function one, the useful concept of a Shared Memory design model will greatly assist the ClubBuffer in its queries to the database, as well as provide it with manageable datasets that can be quickly and easily sorted and displayed to the end-user. While this will likely result in some otherwise unnecessary system complexity, the benefits in terms of efficiency far exceed the potential costs involved. All of this results in an efficient and user-friendly search function that can retrieve data efficiently, quickly sort it by relevance, then display it in an intuitive manner.</p>

        <h3>Function 3: Communication Amongst Members</h3>
        <p>Seek Your Swarm allows users to freely interact with other users and club members, allowing for collaboration, information sharing, and socialization. Users can direct message club leaders and ask about club details before joining. When a user joins a club, they will be added to a group chat with all the other members of that club (FR-6). Club group chats can be used to distribute relevant information about the club. Group chats support image sharing like many well-known chat applications. Club leaders have moderator privileges over the group chat, they can remove inappropriate content and users if needed. </p>
        <p>Because of the sensitive nature of private communication, all messages are end-to-end encrypted. This promotes the data privacy and confidentiality of users. Each user session has a unique encryption key, making messaging more secure (NFR-1). Every message that is sent is encrypted during transit and in storage (NFR-3). For quick and reliable access, messages are stored in an Amazon DynamoDB database (FR-14). </p>
        <p>When a user sends a message, it initiates an event call to the User Interaction module, triggering the sendMessage() function that handles message formatting, encryption, and transmission. sendMessage() formats the message and adds relevant metadata, such as sender and recipient IDs and the timestamp. After the message is formatted it is passed through a symmetric encryption algorithm to ensure that it is unreadable without a key. A digital signature is appended to the message for sender authentication. </p>
        <p>After encryption, the message is transmitted. Client-server architecture allows for the use of the WebSocket protocol. sendMessage() uses this connection to push the encrypted message to the backend server with little delay. The message metadata is logged in the backend database (DynamoDB) and its contents are stored in Amazon S3 (NFR-8). This implementation provides messages that are secure and quick to access (NFR-11). After the backend receives the message and is finished processing it, an acknowledgement is sent back to the sender, so they are aware that it was delivered.  When the message is opened by the recipient it is decrypted using the recipient's decryption key. </p>

        <h3>Function 4: User Roles and Management</h3>
        <p>After the user is logged into their account, they will have the option to edit or delete their profile depending on the situation (FR-8, 9). Only after a user is logged in can they access any of the functions of the rest of the application. This is so that we can allocate resources toward people that we know need to use the application rather than people who are messing around on it. They can also have the option to create and join clubs (FR-7, 13). We decided that only users can join clubs to keep track of everyone who is in the club. To make the process of creating and joining clubs along with editing and deleting accounts efficient and reliable, we have a central user management console that will interact with the database to have an organized way of accessing the database for each user. When creating a club, the user who creates the club is automatically the club leader. We did this since logically, the person who makes the club is going to be the leader of the club. We also did this so that it is easy to store on the database since we can assign the user as the club leader automatically. We also made it so that the club leader can edit and delete the club (FR-10, 11). The club leader can also appoint co-leaders to help manage the club. This feature was made in mind for bigger clubs. These co-leaders can also edit the club, but they cannot delete the club. We did this because the duty of deleting the club should only fall on the top person in the club, which is the club leader. It feels untrustworthy to give the co-leader the ability to delete clubs. Something the club leader and co-leaders can also do is kick members (FR-12). We made this feature in the case of any members being inappropriate and need to be kicked out of the club. </p>
        <p>This module was made to only focus on user actions since that is a big part of the application. By setting it aside, it helps with not only being able to easily test it, but it also helps with isolating it for further development. Within the module there are different sections for user actions. We divided it in a way where it makes the most sense where we put all actions involving interacting with clubs in one section, all actions involving the user account in another, and finally all actions involving user club creation and further management in one section. This also helps to test and isolate for development. </p>

        <h3>Function 5: Database and Storage</h3>
        <p>All user and club data will be stored on an SQL database (FR-1, FR-2). When the User and Club Management modules call any change to the database, the functions will manually access the database and change or get the information necessary from the database. For this case, we decided to use Amazon RDS for PostgreSQL to efficiently set up and operate the databases and the interactions between the modules and the databases. Amazon RDS allows for easy set up and management and allows for precise fine-tuning of the database. PostgreSQL is also used since it is ACID compliant and is fast in complex queries and one of the most efficient RDBMS allowing. This makes creating, editing, and deleting user and club profiles in PostgreSQL very fast (FR-4,7,8,9,10,11,12 NFR-1,2,8). In addition, we also decided to use Amazon RDS Multi-AZ to create multiple copies of the database and make the database highly available (NFR 4, 6). All the messages made by users will be stored on Amazon S3 and will be organized using Amazon DynamoDB (FR-14).  We decided on Amazon S3 due to its incredible scalability, durability, and security (NFR-11). We also decided on Amazon DynamoDB due to its incredible speed and performance (NFR-11). The time it takes for the system to persist data to the database will take less than one second (NFR-8). Using Amazon services for every part of the configuration makes the setup very consistent and easy to access, and it also helps with the scalability of the database system as more and more users join the application. This scalability is especially important in the situation of having more users and clubs than expected, using Amazon S3 and Amazon RDS allows us to scale up easier. It saves us time and money from trying to allocate our own space, and instead making use of Amazon’s servers.  </p>

    </div>
</body>